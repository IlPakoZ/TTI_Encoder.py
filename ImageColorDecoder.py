import argparse
import png
import json

# region Argument Parser

parser = argparse.ArgumentParser(description="Decodes the image generated by the TTI Encoder using the paired key.")
parser.add_argument("-i", "--imagename", type=str, metavar="",
                    help="The name of the image file you want to decode (with its extension).")
parser.add_argument("-k", "--keyname", type=str, metavar="",
                    help="The name of the key file you want to decode (with its extension).")
parser.add_argument("-o", "--output", type=str, metavar="",
                    help="The name of the decoded output text file.")
args = parser.parse_args()

# endregion


def conversion(image, key, output=None):

    # region Variables Declaration Namespace
    img = []
    file_infos = {}
    # endregion

    # Loads the key into memory
    try:
        file_infos = load_key(key)
        session_id = int(file_infos["session-id"], 16)
    except (FileNotFoundError, OSError, TypeError):
        print("The key file doesn't exist or is invalid. The program will terminate.")
        exit(1)

    # Loads the image into memory
    try:
        img = load_image(image)
    except (FileNotFoundError, OSError):
        print("Image file not found. The program will terminate.")
        exit(1)

    # Gets binary code from image and removes the trailing used to create a squared image
    binary_text = remove_trailing(get_binary(img), file_infos["trailing"])

    # Decodes the binary into characters
    decoded_text = decode(file_infos["bits"], binary_text, file_infos["keys"], session_id)

    while True:
        try:
            if not output:
                output = input("Type the path of the decoded text: ")
            with open(output, "w", encoding=file_infos["encoding"]) as f:
                f.write(decoded_text)
        except (FileNotFoundError, OSError):
            print("Invalid path. Please retry.\n")
        else:
            break


# Get binary code from RGB Values
def get_binary(img):
    return "".join([get_bits(8, x) for x in img])


# Loads the file containing the key
def load_key(key):
    file_infos = {}
    with open(key, "r") as f:
        file_infos = json.load(f)
    return file_infos


# Converts the binary sequence into text
def decode(bits, string, decoding_dic, session_id):
    converted_text = ""

    # Converts the binary sequence into text using the decoding dictionary
    try:
        for x in range(0, len(string), bits):
            converted_text += decoding_dic[str(get_integer(string[x:x+bits], session_id, bits))]
    except (IndexError, KeyError, TypeError):
        print("\nBinary sequence, key or image file invalid or damaged! The program will terminate!")
        exit(1)
    return converted_text


# Gets the integer conversion of a binary number
def get_integer(sequence, session_id, bits):
    return (2**bits - (session_id % (2**bits)) + int(sequence, 2)) % (2**bits)


# Gets the binary conversion of an integer
def get_bits(bits, integer):
    return format(integer, "#0" + str(2+bits) + "b")[2:bits+2]


# Loads the image and converts it into an array of numbers.
def load_image(image):
    try:
        img = []
        with open(image, mode='rb') as f:
            reader = png.Reader(file=f)
            w, h, png_img, _ = reader.asRGB8()
            for line in png_img:
                for i in range(len(line)):
                    img.append(line[i])
    except FormatError:
        print("The image file is invalid or corrupted. The program will terminate.")
        exit(1)
    return img


# Removes the useless trailing zeros
def remove_trailing(binary_text, trailing):
    return binary_text[0:-trailing]


# At startup, parses the arguments or asks for the user to input the image and key names
if __name__ == "__main__":
    if args.imagename and args.keyname:
        img_path = args.imagename
        key_path = args.keyname
    elif args.keyname:
        img_path = input("Type the path of the image you want to decode: ")
    elif args.imagename:
        key_path = input("Type the path of the deciphering key: ")
    else:
        img_path = input("Type the path of the image you want to decode: ")
        key_path = input("Type the path of the deciphering key: ")
    conversion(img_path, key_path, args.output)
